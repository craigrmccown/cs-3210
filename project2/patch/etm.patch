diff -rupN -x .git old/include/linux/etm_setup.h new/include/linux/etm_setup.h
--- old/include/linux/etm_setup.h	1970-01-01 00:00:00.000000000 +0000
+++ new/include/linux/etm_setup.h	2015-03-05 03:45:51.863502790 +0000
@@ -0,0 +1,28 @@
+#ifndef ETM_SETUP
+#define ETM_SETUP
+
+#include <linux/slab.h>
+
+#define NUM_THREADS 10
+#define NUM_EPOCHS 10
+
+// struct definitions
+typedef struct etm_measurement {
+	long epoch_id;
+	long measurement;
+} etm_measurement;
+
+typedef struct etm_data {
+	long p_id;
+	int num_u_pthread_create_measurements;
+	etm_measurement* u_pthread_create_measurements;
+	int num_k_clone_measurements;
+	long* k_clone_measurements;
+} etm_data;
+
+// function prototypes
+int etm_allocate(void);
+void etm_free(void);
+void etm_clone(long measurement);
+
+#endif
diff -rupN -x .git old/init/main.c new/init/main.c
--- old/init/main.c	2015-03-05 02:04:26.239412983 +0000
+++ new/init/main.c	2015-03-05 03:37:30.619502790 +0000
@@ -78,6 +78,7 @@
 #include <linux/context_tracking.h>
 #include <linux/random.h>
 #include <linux/list.h>
+#include <linux/etm_setup.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -1030,4 +1031,7 @@ static noinline void __init kernel_init_
 
 	/* rootfs is available now, try loading default modules */
 	load_default_modules();
+
+	/* load etm data */
+	etm_allocate();
 }
diff -rupN -x .git old/kernel/printk/printk.c new/kernel/printk/printk.c
--- old/kernel/printk/printk.c	2015-03-05 02:04:26.267412983 +0000
+++ new/kernel/printk/printk.c	2015-03-05 03:45:37.363502790 +0000
@@ -46,8 +46,11 @@
 #include <linux/irq_work.h>
 #include <linux/utsname.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/etm_setup.h>
 
 #include <asm/uaccess.h>
+#include <asm/current.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
@@ -3058,3 +3061,47 @@ void show_regs_print_info(const char *lo
 }
 
 #endif
+
+// variable declarations
+struct etm_data *execution_time_mod_data;
+
+// function definitions
+int etm_allocate(void) {
+	execution_time_mod_data = kmalloc(sizeof(etm_data), GFP_KERNEL);
+
+	if (execution_time_mod_data == NULL) {
+		return 0;
+	}
+
+	execution_time_mod_data -> p_id = -1;
+	execution_time_mod_data -> num_u_pthread_create_measurements = 0;
+	execution_time_mod_data -> u_pthread_create_measurements = kmalloc(sizeof(etm_measurement) * NUM_EPOCHS * NUM_THREADS, GFP_KERNEL);
+	execution_time_mod_data -> num_k_clone_measurements = 0;
+	execution_time_mod_data -> k_clone_measurements = kmalloc(sizeof(long) * NUM_EPOCHS * NUM_THREADS, GFP_KERNEL);
+
+	if (
+		execution_time_mod_data -> u_pthread_create_measurements == NULL ||
+		execution_time_mod_data -> k_clone_measurements == NULL
+	) {
+		return 0;
+	}
+
+	return 1;
+}
+
+void etm_free(void) {
+	kfree(execution_time_mod_data -> u_pthread_create_measurements);
+	kfree(execution_time_mod_data -> k_clone_measurements);
+	kfree(execution_time_mod_data);
+
+	execution_time_mod_data = NULL;
+}
+
+void etm_clone(long measurement) {
+	if (execution_time_mod_data != NULL && current -> pid == execution_time_mod_data -> p_id) {
+		execution_time_mod_data -> k_clone_measurements[execution_time_mod_data -> num_k_clone_measurements] = measurement;
+		execution_time_mod_data -> num_k_clone_measurements ++;
+	}
+}
+
+EXPORT_SYMBOL_GPL(execution_time_mod_data);
