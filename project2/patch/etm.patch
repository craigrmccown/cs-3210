diff -rupN -x .git old/arch/um/kernel/skas/clone.c new/arch/um/kernel/skas/clone.c
--- old/arch/um/kernel/skas/clone.c	2015-03-05 02:04:22.755412983 +0000
+++ new/arch/um/kernel/skas/clone.c	2015-03-05 06:10:47.324652773 +0000
@@ -11,6 +11,7 @@
 #include <ptrace_user.h>
 #include <stub-data.h>
 #include <sysdep/stub.h>
+#include <linux/timekeeping.h>
 
 /*
  * This is in a separate file because it needs to be compiled with any
@@ -23,6 +24,8 @@
 void __attribute__ ((__section__ (".__syscall_stub")))
 stub_clone_handler(void)
 {
+	struct timespec ts_start,ts_end,ts_total_time;
+	getnstimeofday(&ts_start);
 	struct stub_data *data = (struct stub_data *) STUB_DATA;
 	long err;
 
@@ -52,5 +55,8 @@ stub_clone_handler(void)
 	 */
 	data->err = err;
  done:
+	getnstimeofday(&ts_end);
+	ts_total_time = timespec_sub(ts_end,ts_start);
+	etm_clone(ts_total_time.nv_sec);
 	trap_myself();
 }
diff -rupN -x .git old/include/linux/etm_setup.h new/include/linux/etm_setup.h
--- old/include/linux/etm_setup.h	1970-01-01 00:00:00.000000000 +0000
+++ new/include/linux/etm_setup.h	2015-03-05 06:10:47.324652773 +0000
@@ -0,0 +1,28 @@
+#ifndef ETM_SETUP
+#define ETM_SETUP
+
+#include <linux/slab.h>
+
+#define NUM_THREADS 10
+#define NUM_EPOCHS 10
+
+// struct definitions
+typedef struct etm_measurement {
+	long epoch_id;
+	long measurement;
+} etm_measurement;
+
+typedef struct etm_data {
+	long p_id;
+	int num_u_pthread_create_measurements;
+	etm_measurement* u_pthread_create_measurements;
+	int num_k_clone_measurements;
+	long* k_clone_measurements;
+} etm_data;
+
+// function prototypes
+int etm_allocate(void);
+void etm_free(void);
+void etm_clone(long measurement);
+
+#endif
diff -rupN -x .git old/init/main.c new/init/main.c
--- old/init/main.c	2015-03-05 02:04:26.239412983 +0000
+++ new/init/main.c	2015-03-05 06:10:47.324652773 +0000
@@ -78,6 +78,7 @@
 #include <linux/context_tracking.h>
 #include <linux/random.h>
 #include <linux/list.h>
+#include <linux/etm_setup.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -1030,4 +1031,7 @@ static noinline void __init kernel_init_
 
 	/* rootfs is available now, try loading default modules */
 	load_default_modules();
+
+	/* load etm data */
+	etm_allocate();
 }
diff -rupN -x .git old/kernel/printk/printk.c new/kernel/printk/printk.c
--- old/kernel/printk/printk.c	2015-03-05 02:04:26.267412983 +0000
+++ new/kernel/printk/printk.c	2015-03-05 06:14:50.184652773 +0000
@@ -46,8 +46,11 @@
 #include <linux/irq_work.h>
 #include <linux/utsname.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/etm_setup.h>
 
 #include <asm/uaccess.h>
+#include <asm/current.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
@@ -3058,3 +3061,49 @@ void show_regs_print_info(const char *lo
 }
 
 #endif
+
+// variable declarations
+struct etm_data *execution_time_mod_data;
+
+// function definitions
+int etm_allocate(void) {
+	execution_time_mod_data = kmalloc(sizeof(etm_data), GFP_KERNEL);
+
+	if (execution_time_mod_data == NULL) {
+		return 0;
+	}
+
+	execution_time_mod_data -> p_id = -1;
+	execution_time_mod_data -> num_u_pthread_create_measurements = 0;
+	execution_time_mod_data -> u_pthread_create_measurements = kmalloc(sizeof(etm_measurement) * NUM_EPOCHS * NUM_THREADS, GFP_KERNEL);
+	execution_time_mod_data -> num_k_clone_measurements = 0;
+	execution_time_mod_data -> k_clone_measurements = kmalloc(sizeof(long) * NUM_EPOCHS * NUM_THREADS, GFP_KERNEL);
+
+	if (
+		execution_time_mod_data -> u_pthread_create_measurements == NULL ||
+		execution_time_mod_data -> k_clone_measurements == NULL
+	) {
+		return 0;
+	}
+
+	return 1;
+}
+
+void etm_free(void) {
+	kfree(execution_time_mod_data -> u_pthread_create_measurements);
+	kfree(execution_time_mod_data -> k_clone_measurements);
+	kfree(execution_time_mod_data);
+
+	execution_time_mod_data = NULL;
+}
+
+void etm_clone(long measurement) {
+	if (execution_time_mod_data != NULL && current -> pid == execution_time_mod_data -> p_id) {
+		execution_time_mod_data -> k_clone_measurements[execution_time_mod_data -> num_k_clone_measurements] = measurement;
+		execution_time_mod_data -> num_k_clone_measurements ++;
+	}
+}
+
+EXPORT_SYMBOL_GPL(execution_time_mod_data);
+EXPORT_SYMBOL_GPL(etm_allocate);
+EXPORT_SYMBOL_GPL(etm_free);
